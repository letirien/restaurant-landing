import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  append_styles,
  attr_dev,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  create_component,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  safe_not_equal,
  set_data_dev,
  set_style,
  space,
  svg_element,
  text,
  transition_in,
  transition_out,
  validate_each_argument,
  validate_slots
} from "./chunk-UJLIVLOQ.js";
import "./chunk-RSJERJUL.js";

// node_modules/svelte-star-rating/isNumber.js
var isNumber_default = (n) => typeof n === "number" && n === Number(n) && Number.isFinite(n);

// node_modules/svelte-star-rating/makeUniqueId.js
var makeUniqueId_default = () => "_" + Math.random().toString(36).substr(2, 9);

// node_modules/svelte-star-rating/Star.svelte
var file = "node_modules\\svelte-star-rating\\Star.svelte";
function add_css(target) {
  append_styles(target, "svelte-7nhlqv", "svg.svelte-7nhlqv{width:var(--width);height:var(--height);margin-right:2px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3Rhci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBNENFLGlCQUFJLENBQ0YsS0FBSyxDQUFFLElBQUksT0FBTyxDQUFDLENBQ25CLE1BQU0sQ0FBRSxJQUFJLFFBQVEsQ0FBQyxDQUNyQixZQUFZLENBQUUsR0FDaEIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiU3Rhci5zdmVsdGUiXX0= */");
}
function create_if_block(ctx) {
  let defs;
  let linearGradient;
  let stop0;
  let stop1;
  let stop1_offset_value;
  let stop2;
  let stop2_offset_value;
  let linearGradient_id_value;
  const block = {
    c: function create() {
      defs = svg_element("defs");
      linearGradient = svg_element("linearGradient");
      stop0 = svg_element("stop");
      stop1 = svg_element("stop");
      stop2 = svg_element("stop");
      this.h();
    },
    l: function claim(nodes) {
      defs = claim_svg_element(nodes, "defs", {});
      var defs_nodes = children(defs);
      linearGradient = claim_svg_element(defs_nodes, "linearGradient", {
        id: true,
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      var linearGradient_nodes = children(linearGradient);
      stop0 = claim_svg_element(linearGradient_nodes, "stop", { offset: true, style: true });
      children(stop0).forEach(detach_dev);
      stop1 = claim_svg_element(linearGradient_nodes, "stop", { offset: true, style: true });
      children(stop1).forEach(detach_dev);
      stop2 = claim_svg_element(linearGradient_nodes, "stop", { offset: true, style: true });
      children(stop2).forEach(detach_dev);
      linearGradient_nodes.forEach(detach_dev);
      defs_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(stop0, "offset", "0%");
      set_style(
        stop0,
        "stop-color",
        /*fullColor*/
        ctx[2]
      );
      set_style(stop0, "stop-opacity", "1");
      add_location(stop0, file, 21, 8, 683);
      attr_dev(stop1, "offset", stop1_offset_value = /*full*/
      ctx[1] * 100 + "%");
      set_style(
        stop1,
        "stop-color",
        /*fullColor*/
        ctx[2]
      );
      set_style(stop1, "stop-opacity", "1");
      add_location(stop1, file, 22, 8, 758);
      attr_dev(stop2, "offset", stop2_offset_value = /*full*/
      ctx[1] * 100 + "%");
      set_style(
        stop2,
        "stop-color",
        /*emptyColor*/
        ctx[3]
      );
      set_style(stop2, "stop-opacity", "1");
      add_location(stop2, file, 25, 8, 864);
      attr_dev(linearGradient, "id", linearGradient_id_value = "grad-" + /*id*/
      ctx[0]);
      attr_dev(linearGradient, "x1", "0%");
      attr_dev(linearGradient, "y1", "0%");
      attr_dev(linearGradient, "x2", "100%");
      attr_dev(linearGradient, "y2", "0%");
      add_location(linearGradient, file, 20, 6, 609);
      add_location(defs, file, 19, 4, 596);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, defs, anchor);
      append_hydration_dev(defs, linearGradient);
      append_hydration_dev(linearGradient, stop0);
      append_hydration_dev(linearGradient, stop1);
      append_hydration_dev(linearGradient, stop2);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*fullColor*/
      4) {
        set_style(
          stop0,
          "stop-color",
          /*fullColor*/
          ctx2[2]
        );
      }
      if (dirty & /*full*/
      2 && stop1_offset_value !== (stop1_offset_value = /*full*/
      ctx2[1] * 100 + "%")) {
        attr_dev(stop1, "offset", stop1_offset_value);
      }
      if (dirty & /*fullColor*/
      4) {
        set_style(
          stop1,
          "stop-color",
          /*fullColor*/
          ctx2[2]
        );
      }
      if (dirty & /*full*/
      2 && stop2_offset_value !== (stop2_offset_value = /*full*/
      ctx2[1] * 100 + "%")) {
        attr_dev(stop2, "offset", stop2_offset_value);
      }
      if (dirty & /*emptyColor*/
      8) {
        set_style(
          stop2,
          "stop-color",
          /*emptyColor*/
          ctx2[3]
        );
      }
      if (dirty & /*id*/
      1 && linearGradient_id_value !== (linearGradient_id_value = "grad-" + /*id*/
      ctx2[0])) {
        attr_dev(linearGradient, "id", linearGradient_id_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(defs);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(19:2) {#if full !== 1 && full !== 0}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let svg;
  let path;
  let path_fill_value;
  let if_block = (
    /*full*/
    ctx[1] !== 1 && /*full*/
    ctx[1] !== 0 && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        viewBox: true,
        height: true,
        style: true,
        class: true
      });
      var svg_nodes = children(svg);
      if (if_block)
        if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", path_fill_value = /*full*/
      ctx[1] === 1 ? (
        /*fullColor*/
        ctx[2]
      ) : (
        /*full*/
        ctx[1] === 0 ? (
          /*emptyColor*/
          ctx[3]
        ) : `url(#grad-${/*id*/
        ctx[0]})`
      ));
      attr_dev(path, "d", "M187.183 57.47a9.955 9.955 0\n    00-8.587-6.86l-54.167-4.918-21.42-50.134a9.978 9.978 0 00-9.172-6.052 9.972\n    9.972 0 00-9.172 6.061l-21.42 50.125L9.07 50.611a9.973 9.973 0 00-8.578\n    6.858 9.964 9.964 0 002.917 10.596l40.944 35.908-12.073 53.184a9.97 9.97 0\n    003.878 10.298A9.953 9.953 0 0042 169.357a9.937 9.937 0\n    005.114-1.424l46.724-27.925 46.707 27.925a9.936 9.936 0 0010.964-.478 9.979\n    9.979 0 003.88-10.298l-12.074-53.184 40.944-35.9a9.98 9.98 0\n    002.925-10.604zm0 0");
      add_location(path, file, 31, 2, 1009);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "249.748");
      attr_dev(svg, "viewBox", "0 -10 187.673 179.503");
      attr_dev(svg, "height", "239.338");
      set_style(
        svg,
        "--width",
        /*width*/
        ctx[4]
      );
      set_style(
        svg,
        "--height",
        /*height*/
        ctx[5]
      );
      attr_dev(svg, "class", "svelte-7nhlqv");
      add_location(svg, file, 11, 0, 353);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*full*/
        ctx2[1] !== 1 && /*full*/
        ctx2[1] !== 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*full, fullColor, emptyColor, id*/
      15 && path_fill_value !== (path_fill_value = /*full*/
      ctx2[1] === 1 ? (
        /*fullColor*/
        ctx2[2]
      ) : (
        /*full*/
        ctx2[1] === 0 ? (
          /*emptyColor*/
          ctx2[3]
        ) : `url(#grad-${/*id*/
        ctx2[0]})`
      ))) {
        attr_dev(path, "fill", path_fill_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Star", slots, []);
  let { id } = $$props;
  let { full } = $$props;
  let { fullColor = "#ffcf00" } = $$props;
  let { emptyColor = "#7f7f7f" } = $$props;
  let { size = 20 } = $$props;
  const width = `${size}px`;
  const height = width;
  $$self.$$.on_mount.push(function() {
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<Star> was created without expected prop 'id'");
    }
    if (full === void 0 && !("full" in $$props || $$self.$$.bound[$$self.$$.props["full"]])) {
      console.warn("<Star> was created without expected prop 'full'");
    }
  });
  const writable_props = ["id", "full", "fullColor", "emptyColor", "size"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Star> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("full" in $$props2)
      $$invalidate(1, full = $$props2.full);
    if ("fullColor" in $$props2)
      $$invalidate(2, fullColor = $$props2.fullColor);
    if ("emptyColor" in $$props2)
      $$invalidate(3, emptyColor = $$props2.emptyColor);
    if ("size" in $$props2)
      $$invalidate(6, size = $$props2.size);
  };
  $$self.$capture_state = () => ({
    id,
    full,
    fullColor,
    emptyColor,
    size,
    width,
    height
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("full" in $$props2)
      $$invalidate(1, full = $$props2.full);
    if ("fullColor" in $$props2)
      $$invalidate(2, fullColor = $$props2.fullColor);
    if ("emptyColor" in $$props2)
      $$invalidate(3, emptyColor = $$props2.emptyColor);
    if ("size" in $$props2)
      $$invalidate(6, size = $$props2.size);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [id, full, fullColor, emptyColor, width, height, size];
}
var Star = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        id: 0,
        full: 1,
        fullColor: 2,
        emptyColor: 3,
        size: 6
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Star",
      options,
      id: create_fragment.name
    });
  }
  get id() {
    throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get full() {
    throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set full(value) {
    throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullColor() {
    throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullColor(value) {
    throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get emptyColor() {
    throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set emptyColor(value) {
    throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Star_default = Star;

// node_modules/svelte-star-rating/StarRating.svelte
var { Error: Error_1 } = globals;
var file2 = "node_modules\\svelte-star-rating\\StarRating.svelte";
function add_css2(target) {
  append_styles(target, "svelte-g1srw1", "div.svelte-g1srw1{display:flex;margin-bottom:14px}span.svelte-g1srw1{color:#7f7f7f;line-height:1;align-self:center;margin-left:8px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3RhclJhdGluZy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBeUNFLGlCQUFJLENBQ0YsT0FBTyxDQUFFLElBQUksQ0FDYixhQUFhLENBQUUsSUFDakIsQ0FDQSxrQkFBSyxDQUNILEtBQUssQ0FBRSxPQUFPLENBQ2QsV0FBVyxDQUFFLENBQUMsQ0FDZCxVQUFVLENBQUUsTUFBTSxDQUNsQixXQUFXLENBQUUsR0FDZiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJTdGFyUmF0aW5nLnN2ZWx0ZSJdfQ== */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let star;
  let current;
  star = new Star_default({
    props: {
      id: (
        /*id*/
        ctx[4]
      ),
      full: (
        /*star*/
        ctx[13]
      ),
      emptyColor: (
        /*config*/
        ctx[2].emptyColor
      ),
      fullColor: (
        /*config*/
        ctx[2].fullColor
      ),
      size: (
        /*size*/
        ctx[5]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(star.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(star.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(star, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const star_changes = {};
      if (dirty & /*stars*/
      8)
        star_changes.full = /*star*/
        ctx2[13];
      if (dirty & /*config*/
      4)
        star_changes.emptyColor = /*config*/
        ctx2[2].emptyColor;
      if (dirty & /*config*/
      4)
        star_changes.fullColor = /*config*/
        ctx2[2].fullColor;
      star.$set(star_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(star.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(star.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(star, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(30:2) {#each stars as star}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*rating*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { style: true, class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*rating*/
        ctx[0]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(
        span,
        "font-size",
        /*fontSize*/
        ctx[6] + "px"
      );
      attr_dev(span, "class", "svelte-g1srw1");
      add_location(span, file2, 37, 23, 1246);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*rating*/
      1)
        set_data_dev(
          t,
          /*rating*/
          ctx2[0]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(38:2) {#if config.showText}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div;
  let t;
  let current;
  let each_value = (
    /*stars*/
    ctx[3]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block = (
    /*config*/
    ctx[2].showText && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { style: true, class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      t = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "style",
        /*style*/
        ctx[1]
      );
      attr_dev(div, "class", "svelte-g1srw1");
      add_location(div, file2, 28, 0, 1048);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append_hydration_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*id, stars, config, size*/
      60) {
        each_value = /*stars*/
        ctx2[3];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, t);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (
        /*config*/
        ctx2[2].showText
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & /*style*/
      2) {
        attr_dev(
          div,
          "style",
          /*style*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let full;
  let half;
  let empty;
  let fullArr;
  let halfArr;
  let emptyArr;
  let stars;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StarRating", slots, []);
  let { rating } = $$props;
  let { style = "" } = $$props;
  let { config = {} } = $$props;
  const id = makeUniqueId_default();
  const size = config.size && isNumber_default(config.size) ? config.size : 20;
  const fontSize = size / 2 < 16 ? 16 : size / 2;
  $$self.$$.on_mount.push(function() {
    if (rating === void 0 && !("rating" in $$props || $$self.$$.bound[$$self.$$.props["rating"]])) {
      console.warn("<StarRating> was created without expected prop 'rating'");
    }
  });
  const writable_props = ["rating", "style", "config"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<StarRating> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("rating" in $$props2)
      $$invalidate(0, rating = $$props2.rating);
    if ("style" in $$props2)
      $$invalidate(1, style = $$props2.style);
    if ("config" in $$props2)
      $$invalidate(2, config = $$props2.config);
  };
  $$self.$capture_state = () => ({
    isNumber: isNumber_default,
    makeUniqueId: makeUniqueId_default,
    Star: Star_default,
    rating,
    style,
    config,
    id,
    size,
    fontSize,
    emptyArr,
    halfArr,
    fullArr,
    stars,
    empty,
    half,
    full
  });
  $$self.$inject_state = ($$props2) => {
    if ("rating" in $$props2)
      $$invalidate(0, rating = $$props2.rating);
    if ("style" in $$props2)
      $$invalidate(1, style = $$props2.style);
    if ("config" in $$props2)
      $$invalidate(2, config = $$props2.config);
    if ("emptyArr" in $$props2)
      $$invalidate(7, emptyArr = $$props2.emptyArr);
    if ("halfArr" in $$props2)
      $$invalidate(8, halfArr = $$props2.halfArr);
    if ("fullArr" in $$props2)
      $$invalidate(9, fullArr = $$props2.fullArr);
    if ("stars" in $$props2)
      $$invalidate(3, stars = $$props2.stars);
    if ("empty" in $$props2)
      $$invalidate(10, empty = $$props2.empty);
    if ("half" in $$props2)
      $$invalidate(11, half = $$props2.half);
    if ("full" in $$props2)
      $$invalidate(12, full = $$props2.full);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*rating*/
    1) {
      $:
        if (!isNumber_default(rating) || rating < 0 || rating > 5) {
          throw new Error("rating value is not valid! 🙅‍♀️");
        }
    }
    if ($$self.$$.dirty & /*rating*/
    1) {
      $:
        $$invalidate(12, full = Math.floor(rating));
    }
    if ($$self.$$.dirty & /*rating, full*/
    4097) {
      $:
        $$invalidate(11, half = rating - full);
    }
    if ($$self.$$.dirty & /*rating*/
    1) {
      $:
        $$invalidate(10, empty = Math.floor(5 - rating));
    }
    if ($$self.$$.dirty & /*full*/
    4096) {
      $:
        $$invalidate(9, fullArr = Array(full).fill(1));
    }
    if ($$self.$$.dirty & /*half*/
    2048) {
      $:
        $$invalidate(8, halfArr = half !== 0 ? [half] : []);
    }
    if ($$self.$$.dirty & /*empty*/
    1024) {
      $:
        $$invalidate(7, emptyArr = Array(empty).fill(0));
    }
    if ($$self.$$.dirty & /*fullArr, halfArr, emptyArr*/
    896) {
      $:
        $$invalidate(3, stars = fullArr.concat(halfArr).concat(emptyArr));
    }
  };
  return [
    rating,
    style,
    config,
    stars,
    id,
    size,
    fontSize,
    emptyArr,
    halfArr,
    fullArr,
    empty,
    half,
    full
  ];
}
var StarRating = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { rating: 0, style: 1, config: 2 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StarRating",
      options,
      id: create_fragment2.name
    });
  }
  get rating() {
    throw new Error_1("<StarRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rating(value) {
    throw new Error_1("<StarRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error_1("<StarRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error_1("<StarRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get config() {
    throw new Error_1("<StarRating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error_1("<StarRating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StarRating_default = StarRating;

// node_modules/svelte-star-rating/index.js
var svelte_star_rating_default = StarRating_default;
export {
  svelte_star_rating_default as default
};
//# sourceMappingURL=svelte-star-rating.js.map
